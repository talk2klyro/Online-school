<!--
  index-upgraded.html
  Upgraded single-file implementation and developer guide for your School Admin SaaS

  Major goals achieved in this upgrade:
  - Removed duplicates and consolidated page structure
  - Clear separation of concerns: UI, client logic, and server interactions
  - Secure handling model: NO secret keys in client; placeholders use build/env variables
  - Lazy-load heavy libs (Chart.js, jsPDF, html2canvas) only when needed
  - Ably: uses authUrl token flow so client never contains secret key
  - Cloudinary and Neon: demonstrated server-signed flows (see SERVER SAMPLE)
  - Accessibility and responsiveness improvements
  - Better memory management: charts destroyed and canvases removed after use
  - Actionable dev-ops recommendations included in comments

  IMPORTANT SECURITY NOTE (READ FIRST):
  - I have REMOVED all sensitive keys you pasted. Do NOT store secrets in client-side code.
  - Because you pasted keys publicly, rotate/regenerate the following immediately in their provider consoles:
    * Magic secret keys, Ably API keys, Cloudinary API secret, Neon DB credentials
  - Use .env on the server and provider secrets management. Example .env.example is included below.

  How to use this document:
  - Open in your editor. Replace placeholder env variables at build-time or set them in your hosting dashboard.
  - Implement the minimal server endpoints (server sample included) to provide tokenized access for Ably, signed uploads for Cloudinary, and to proxy DB queries to Neon.

  Want this converted to React+Vite components (recommended)? I can produce that next ‚Äî but I made this file ready to be ported.

  (Generated by GPT-5 Thinking mini.)
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>School Admin SaaS ‚Äî Upgraded</title>
  <!-- Replace with your real CSS / Tailwind build in production -->
  <link rel="stylesheet" href="styles.css">
  <meta name="description" content="School Admin SaaS dashboard with secure integrations and PDF export." />
  <!-- Performance: preload fonts and critical assets when using a bundler -->
  <!-- Security: set CSP HTTP header on server; do not rely on meta for production CSP -->
</head>
<body class="min-h-screen bg-gray-50 text-gray-800">
  <header class="header p-4 shadow-sm bg-white sticky top-0 z-20 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <div class="text-2xl">üè´</div>
      <div>
        <div class="font-semibold">School Admin SaaS</div>
        <div class="text-xs text-gray-500">KPI Dashboard & Reports</div>
      </div>
    </div>
    <nav>
      <button id="logoutBtn" aria-label="Logout" class="btn">Logout</button>
    </nav>
  </header>

  <main class="p-6 max-w-7xl mx-auto">
    <section class="card p-4 bg-white shadow rounded-md mb-6">
      <label for="select-multiple-classes" class="font-medium">Select Class(es)</label>
      <select id="select-multiple-classes" multiple aria-label="Select classes" class="mt-2 w-full p-2 border rounded">
        <!-- Populated by JS -->
      </select>
      <div class="mt-4 flex gap-3">
        <button id="refreshBtn" class="btn">Refresh</button>
        <button id="export-multi-class-pdf" class="btn-primary">Export Interactive PDF</button>
        <div id="exportStatus" class="text-sm text-gray-500 ml-2" aria-live="polite"></div>
      </div>
    </section>

    <section id="kpiCards" class="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3"></section>
  </main>

  <footer class="p-4 text-center text-gray-500 text-sm">&copy; 2025 School Admin SaaS</footer>

  <!-- Minimal inline styles for demo. Replace with Tailwind/build CSS. -->
  <style>
    .btn{padding:.5rem 1rem;border-radius:.5rem;border:1px solid #e5e7eb;background:#fff}
    .btn-primary{padding:.6rem 1rem;border-radius:.6rem;background:#2563eb;color:#fff;border:0}
    .card{border:1px solid #e6e7eb}
  </style>

  <!-- Main JS: module for modern browsers -->
  <script type="module">
  // -------------------------
  // CONFIG ‚Äî BUILD/TIME ENV
  // -------------------------
  // NOTE: Replace these via your bundler environment injection (Vite: import.meta.env.VITE_*)
  // In production: NEVER embed secret API keys in client. Use the server endpoints shown in the SERVER SAMPLE below.

  const CONFIG = {
    // Client-only/public keys (safe to expose):
    MAGIC_PUBLISHABLE: import.meta?.env?.VITE_MAGIC_PUBLISHABLE || '__MAGIC_PUBLISHABLE__',
    CLOUDINARY_CLOUD_NAME: import.meta?.env?.VITE_CLOUDINARY_CLOUD_NAME || '__CLOUD_NAME__',

    // Server endpoints (must be implemented server-side and should be secured):
    API_BASE: import.meta?.env?.VITE_API_BASE || '', // e.g. https://api.yoursaas.com
    ABLY_AUTH_URL: '/api/ably/token', // returns Ably tokenRequest or acts as authUrl
    CLOUDINARY_SIGN_URL: '/api/cloudinary/sign',
    NEON_PROXY_BASE: '/api', // routes for classes, resources, analytics
    MAGIC_SERVER_VERIFY: '/api/magic/verify'
  };

  // -------------------------
  // HELPERS
  // -------------------------
  function el(id){return document.getElementById(id)}
  function createScript(src){
    return new Promise((resolve,reject)=>{
      const s=document.createElement('script'); s.src=src; s.async=true;
      s.onload=()=>resolve(); s.onerror=(e)=>reject(e); document.head.appendChild(s);
    });
  }

  function showStatus(msg, timeout=4000){
    const s = el('exportStatus'); s.textContent = msg; if(timeout) setTimeout(()=>{ if(s.textContent===msg) s.textContent=''; }, timeout);
  }

  // Small utility to lazy load UMD libs if needed (jsPDF/Chart.js are large). CDN choice: your bundler + pin version.
  async function ensureChartAndPDF(){
    if(window.Chart && window.jspdf) return;
    // Chart.js (UMD build) and jsPDF
    if(!window.Chart){
      await createScript('https://cdn.jsdelivr.net/npm/chart.js');
    }
    if(!window.jspdf){
      await createScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
    }
    // html2canvas for rendering DOM to canvas (optional but useful)
    if(!window.html2canvas){
      await createScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
    }
  }

  // Temporary canvas lifecycle: create -> use -> destroy (avoid memory leaks)
  function createTempCanvas(id, width=800, height=400){
    const c = document.createElement('canvas'); c.id = id; c.width = width; c.height = height; c.style.display='none';
    document.body.appendChild(c); return c; }
  function destroyTempCanvas(c){ if(!c) return; c.remove(); }

  // Spike detection (kept simple & stable)
  function detectSpikes(data){
    if(!Array.isArray(data) || data.length===0) return [];
    const mean = data.reduce((a,b)=>a+b,0)/data.length;
    const stdDev = Math.sqrt(data.map(x=>Math.pow(x-mean,2)).reduce((a,b)=>a+b,0)/data.length);
    return data.map((v,i)=>({index:i, value:v, isSpike: v > mean + 1.5*stdDev}));
  }

  // -------------------------
  // AUTH: choose one provider
  // -------------------------
  // NOTE: You included both Clerk and Magic in the previous file. Pick one provider in production.
  // - Magic (passwordless) requires server verification of DID tokens for secure sessions
  // - Clerk is a full auth solution with hosted sessions; integrate via Clerk's official docs

  // Example: initialize Magic on client (publishable key only). The server must validate tokens.
  let magicClient = null;
  async function initMagic(){
    if(typeof window.Magic === 'undefined'){
      // load CDN Magic client (if you prefer the npm package, use bundler)
      await createScript('https://cdn.jsdelivr.net/npm/magic-sdk/dist/magic.js');
    }
    try{
      magicClient = new window.Magic(CONFIG.MAGIC_PUBLISHABLE);
      // Example: check user logged in (see Magic docs for current SDK methods)
      // const isLoggedIn = await magicClient.user.isLoggedIn();
      // if(!isLoggedIn) (show login UI)
    }catch(e){ console.warn('Magic init failed', e); }
  }

  // -------------------------
  // ABLY: realtime (token auth)
  // -------------------------
  // Do NOT put Ably API keys in the client. Use authUrl token flow.
  let ablyRealtime = null;
  async function initAbly(){
    if(typeof Ably === 'undefined'){
      await createScript('https://cdn.ably.io/lib/ably.min-1.js');
    }
    try{
      // Option A: let Ably fetch tokenRequest from authUrl
      ablyRealtime = new Ably.Realtime({ authUrl: CONFIG.ABLY_AUTH_URL });
      // Option B: fetch a tokenRequest yourself and pass tokenDetails. Both require server endpoint.
      // const tokenRes = await fetch(CONFIG.ABLY_AUTH_URL); const tokenRequest = await tokenRes.json();
      // ablyRealtime = new Ably.Realtime({ token: tokenRequest });

      // Example: subscribe to a channel for live updates
      const channel = ablyRealtime.channels.get('class-updates');
      channel.subscribe((msg)=>{
        // handle live events: attendance updates, new uploads, etc.
        console.log('Ably message', msg);
      });
    }catch(e){ console.error('Ably init failed', e); }
  }

  // -------------------------
  // FETCH helpers for your API endpoints (server must implement data + security)
  // -------------------------
  async function apiGET(path){
    const url = (CONFIG.API_BASE || '') + path;
    const res = await fetch(url, {credentials:'include'});
    if(!res.ok) throw new Error(`API ${path} failed: ${res.status}`);
    return res.json();
  }

  async function fetchKPIsForClass(classId){ return apiGET(`/api/kpi_summary?class_id=${encodeURIComponent(classId)}`); }
  async function fetchKPITrends(classId){
    const [weekly, monthly] = await Promise.all([
      apiGET(`/analytics/kpi_weekly?class_id=${encodeURIComponent(classId)}`),
      apiGET(`/analytics/kpi_monthly?class_id=${encodeURIComponent(classId)}`)
    ]);
    return { weeklyData: weekly, monthlyData: monthly };
  }
  async function fetchFileSpikes(classId){ return apiGET(`/analytics/file_spikes?class_id=${encodeURIComponent(classId)}`); }
  async function fetchResources(classId){ return apiGET(`/api/resources?class_id=${encodeURIComponent(classId)}`); }

  async function fetchAllFiles(selectedClassIds){
    const files = [];
    for(const id of selectedClassIds){
      const r = await fetchResources(id);
      files.push(...(r||[]).map(rr=>({...rr, classId: id}))); // normalize
    }
    return files;
  }

  // -------------------------
  // CHARTS & PDF generation ‚Äî memory-safe
  // -------------------------
  // All heavy libs lazy-loaded. Charts created on temporary canvases and destroyed.

  function makeChart(canvas, cfg){
    // returns Chart instance
    return new Chart(canvas.getContext('2d'), cfg);
  }

  async function generateKPICharts(kpi, classId){
    await ensureChartAndPDF();
    // create small hidden canvases
    const topFilesCanvas = createTempCanvas(`topFiles-${classId}`, 600, 300);
    const topUploadersCanvas = createTempCanvas(`topUploaders-${classId}`, 600, 300);

    const topFilesCfg = {
      type: 'pie',
      data: { labels: kpi.topFiles.map(f=>f.name), datasets: [{ data: kpi.topFiles.map(f=>f.downloads) }] }
    };
    const topUploadersCfg = {
      type: 'bar',
      data: { labels: kpi.topUploaders.map(u=>u.name), datasets: [{ label: 'Uploads', data: kpi.topUploaders.map(u=>u.uploads) }] }
    };

    const c1 = makeChart(topFilesCanvas, topFilesCfg);
    const c2 = makeChart(topUploadersCanvas, topUploadersCfg);

    return { topFilesCanvas, topUploadersCanvas, chartInstances: [c1,c2] };
  }

  function destroyCharts(instances){
    if(!instances) return;
    for(const ch of instances){ try{ ch.destroy(); }catch(e){} }
  }

  // Minimal spike-aware trend chart
  async function generateTrendChart(trends, classId){
    const c = createTempCanvas(`trend-${classId}`, 900, 300);
    const spikes = detectSpikes(trends.weeklyData.uploads || trends.weeklyData);
    const cfg = { type: 'line', data: { labels: trends.weeklyData.labels || [], datasets: [{ label: 'Uploads', data: trends.weeklyData.uploads || [], fill:false }] } };
    const instance = makeChart(c, cfg);
    return { canvas: c, instance };
  }

  // PDF: uses jsPDF + html2canvas for DOM sections, and chart canvases rendered as images.
  async function exportMultiClassPDF(selectedClassIds){
    showStatus('Preparing export...');
    await ensureChartAndPDF();
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', format: 'a4' });

    // summary page
    const allFiles = await fetchAllFiles(selectedClassIds);
    doc.setFontSize(16); doc.text('üìã Summary of All Files', 40, 60);
    doc.setFontSize(10);
    let y = 80;

    for(const f of allFiles){
      const line = `${f.classId} | ${f.file_name} | ${f.category} | ${f.uploaded_by} | Downloads: ${f.downloads}`;
      doc.text(line, 40, y);
      y += 12; if(y > 720){ doc.addPage(); y = 60; }
    }

    // Per-class pages with charts
    for(const classId of selectedClassIds){
      showStatus(`Exporting class ${classId}...`);
      const kpi = await fetchKPIsForClass(classId);
      const trends = await fetchKPITrends(classId);

      doc.addPage(); doc.setFontSize(14); doc.text(`Class: ${classId} ‚Äî KPI Summary`, 40, 50);

      doc.setFontSize(12); doc.text(`Total Uploads: ${kpi.totalUploads || 0}`, 40, 70);
      doc.text(`Total Downloads: ${kpi.totalDownloads || 0}`, 40, 88);

      // spike alerts
      const spikes = await fetchFileSpikes(classId);
      if(spikes && spikes.length){ doc.setFontSize(11); doc.text('‚ö†Ô∏è File spike alerts:', 40, 110); let y2=124; spikes.forEach(s=>{ doc.text(`${s.file_name} spiked (${s.count})`, 48, y2); y2+=10; }); }

      // Charts -> generate canvases and embed
      const { topFilesCanvas, topUploadersCanvas, chartInstances } = await generateKPICharts(kpi, classId);
      // Trend chart
      const { canvas: trendCanvas, instance: trendInstance } = await generateTrendChart(trends, classId);

      // Convert canvases to dataURL and add to PDF
      try{
        doc.addImage(topFilesCanvas.toDataURL('image/png'), 'PNG', 40, 180, 250, 140);
        doc.addImage(topUploadersCanvas.toDataURL('image/png'), 'PNG', 320, 180, 250, 140);
        doc.addImage(trendCanvas.toDataURL('image/png'), 'PNG', 40, 340, 530, 180);
      }catch(e){ console.warn('Failed to add chart to PDF', e); }

      // cleanup charts & canvases
      destroyCharts(chartInstances.concat([trendInstance]));
      [topFilesCanvas, topUploadersCanvas, trendCanvas].forEach(destroyTempCanvas);
    }

    showStatus('Finalizing PDF...');
    doc.save('multi_class_interactive_report.pdf');
    showStatus('PDF ready ‚úÖ', 5000);
  }

  // -------------------------
  // UI wiring & initialization
  // -------------------------
  el('export-multi-class-pdf').addEventListener('click', async ()=>{
    const selectedOptions = [...el('select-multiple-classes').selectedOptions].map(o=>o.value);
    if(!selectedOptions.length){ alert('Please select at least one class'); return; }
    try{ await exportMultiClassPDF(selectedOptions); }catch(err){ console.error(err); alert('Export failed: ' + err.message); }
  });

  el('refreshBtn').addEventListener('click', initDashboard);

  el('logoutBtn').addEventListener('click', async ()=>{
    // Implement logout server-side and invalidate session / cookie. If using Magic, call server to destroy session.
    try{ await fetch('/api/logout', {method:'POST', credentials:'include'}); location.reload(); }catch(e){ console.warn('Logout failed', e); location.reload(); }
  });

  async function initDashboard(){
    try{
      // Initialize optional 3rd party clients (Magic, Ably). They are safe when used with server-side flows.
      await initMagic();
      await initAbly();

      // Fetch classes
      const res = await fetch('/api/classes', { credentials:'include' });
      if(!res.ok){ throw new Error('Failed to fetch classes'); }
      const classes = await res.json();
      const select = el('select-multiple-classes'); select.innerHTML = '';
      classes.forEach(c=>{ const opt = document.createElement('option'); opt.value = c.id; opt.textContent = c.name; select.appendChild(opt); });

      // populate first KPI card for convenience
      if(classes.length){
        const container = el('kpiCards'); container.innerHTML = '';
        const first = classes[0];
        const kpi = await fetchKPIsForClass(first.id);
        const card = document.createElement('div'); card.className='card p-4 bg-white rounded';
        card.innerHTML = `<h3 class="font-semibold">${first.name} KPIs</h3><p>Total Uploads: ${kpi.totalUploads||0}</p><p>Total Downloads: ${kpi.totalDownloads||0}</p>`;
        container.appendChild(card);
      }
    }catch(e){ console.error('initDashboard error', e); showStatus('Init failed ‚Äî see console'); }
  }

  // Start
  initDashboard();
  </script>

  <!--
    -------------------------
    SERVER SAMPLE (Node/Express) ‚Äî Include in your server project (server.js)
    -------------------------
    NOTE: store all secrets in server .env and never commit them. The example below is illustrative ‚Äî run npm i express dotenv ably cloudinary pg @magic-sdk/admin

    // server.js (abridged)
    const express = require('express');
    const dotenv = require('dotenv');
    const Ably = require('ably');
    const cloudinary = require('cloudinary').v2;
    const { Pool } = require('pg');
    const { Magic } = require('@magic-sdk/admin');

    dotenv.config();
    const app = express();
    app.use(express.json());

    // Configure libs with env secrets (NEVER expose these to client)
    const ablyRest = new Ably.Rest({ key: process.env.ABLY_API_KEY });
    cloudinary.config({ cloud_name: process.env.CLOUDINARY_CLOUD_NAME, api_key: process.env.CLOUDINARY_API_KEY, api_secret: process.env.CLOUDINARY_API_SECRET });
    const pool = new Pool({ connectionString: process.env.NEON_CONNECTION_STRING, ssl: { rejectUnauthorized: false } });
    const magicAdmin = new Magic(process.env.MAGIC_SECRET_KEY);

    // Ably token request endpoint (client can be configured with authUrl pointing here)
    app.get('/api/ably/token', async (req, res) => {
      try{
        const tokenRequest = await new Promise((resolve, reject) => {
          ablyRest.auth.createTokenRequest({}, (err, tokenReq) => err ? reject(err) : resolve(tokenReq));
        });
        res.json(tokenRequest);
      }catch(e){ console.error(e); res.status(500).json({error:'failed to create ably token'}); }
    });

    // Cloudinary signing endpoint for signed uploads
    app.post('/api/cloudinary/sign', (req, res) => {
      // server calculates signature for client-side upload params (timestamp, folder, etc.)
      const timestamp = Math.floor(Date.now()/1000);
      const paramsToSign = { timestamp };
      const signature = cloudinary.utils.api_sign_request(paramsToSign, process.env.CLOUDINARY_API_SECRET);
      res.json({ signature, api_key: process.env.CLOUDINARY_API_KEY, cloud_name: process.env.CLOUDINARY_CLOUD_NAME, timestamp });
    });

    // Example DB proxy endpoints (parameterize queries and validate session!)
    app.get('/api/classes', async (req, res) => {
      // Validate session (e.g., via magic admin or cookie) BEFORE querying DB
      // const didToken = req.headers.authorization?.split('Bearer ')[1];
      // await magicAdmin.users.getMetadataByToken(didToken);
      const { rows } = await pool.query('SELECT id, name FROM classes ORDER BY name');
      res.json(rows);
    });

    // Implement /api/resources, /api/kpi_summary, /analytics/* similarly using parameterized queries

    app.listen(process.env.PORT || 3000, ()=>console.log('Server listening'));

    -------------------------
    .env.example (server-only, never commit real values)

    PORT=3000
    # Ably: server key (rotate if exposed)
    ABLY_API_KEY=YOUR_ABLY_KEY_GOES_HERE

    # Cloudinary: server api + secret (do not put in client)
    CLOUDINARY_CLOUD_NAME=your_cloud_name
    CLOUDINARY_API_KEY=your_cloudinary_api_key
    CLOUDINARY_API_SECRET=your_cloudinary_api_secret

    # Magic (admin secret used only server-side)
    MAGIC_SECRET_KEY=sk_live_...

    # Neon (Postgres) connection string (server-side only)
    NEON_CONNECTION_STRING=postgresql://user:password@host:port/dbname?sslmode=require

    # Frontend-only publishable keys (prefixed with VITE_ if using Vite)
    VITE_MAGIC_PUBLISHABLE=pk_live_...
    VITE_CLOUDINARY_CLOUD_NAME=your_cloud_name
    VITE_API_BASE=https://api.yoursaas.com

    -------------------------
    SECURITY CHECKLIST (actionables):
    1) ROTATE KEYS: Immediately revoke & regenerate any keys you pasted publicly.
    2) Remove secrets from Git history (use git filter-repo or BFG) and rotate keys after cleaning.
    3) Use server-side token flows for realtime (Ably) and signed uploads (Cloudinary).
    4) Use provider secret storage (Vercel/Netlify/GCP/AWS Secrets Manager) for deployed secrets.
    5) Add CSP, secure cookies (HttpOnly, Secure, SameSite=strict), and CORS rules on server.
    6) Add tests, CI linting, and pre-commit hooks to prevent accidental secret commits.

    -------------------------
  -->
</body>
</html>
